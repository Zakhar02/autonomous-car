// THIS IS AN AUTOMATICALLY GENERATED FILE.  DO NOT MODIFY
// BY HAND!!
//
// Generated by lcm-gen

package lcmtest

import (
	"encoding/binary"
	"fmt"
	"math"
	"math/bits"
)

const _ = math.Pi
const _ = bits.UintSize

const primitives_t_Fingerprint uint64 = 0xc2731598914f36aa

// Contains a number of primitive data types
type LcmtestPrimitivesT struct {
	// 8-bit signed integer
	I8          int8       `i8`
	// 16-bit signed integer
	I16         int16      `i16`
	// 32-bit signed integer
	numRanges   int32      `num_ranges`
	// 64-bit signed integer
	I64         int64      `i64`
	// variable-length array of 16-bit signed integers.  The length of this
	// array (# of elements) is specified by the num_ranges field.
	Ranges      []int16    `ranges`
	// fixed-length array of single precision floats.
	Position    [3]float32 `position`
	// fixed-length array of double precision floats.
	Orientation [4]float64 `orientation`
	// variable-length UTF-8 string
	Name        string     `name`
	// a single boolean value
	Enabled     bool       `enabled`
}

// Copy creates a deep copy
// TODO: fix the fugly x and p names...
func (x *LcmtestPrimitivesT) Copy() (p LcmtestPrimitivesT) {
	p.I8 = x.I8

	p.I16 = x.I16

	p.numRanges = x.numRanges

	p.I64 = x.I64

	p.Ranges = make([]int16, p.numRanges)
	for i0 := int32(0); i0 < p.numRanges; i0++ {
		p.Ranges[i0] = x.Ranges[i0]
	}

	for i0 := 0; i0 < 3; i0++ {
		p.Position[i0] = x.Position[i0]
	}

	for i0 := 0; i0 < 4; i0++ {
		p.Orientation[i0] = x.Orientation[i0]
	}

	p.Name = x.Name

	p.Enabled = x.Enabled

	return
}

// Encode encodes a message (fingerprint & data) into binary form
//
// returns Encoded data or error
func (p *LcmtestPrimitivesT) Encode() (data []byte, err error) {
	var size int
	if size, err = p.Size(); err != nil {
		return
	}

	data = make([]byte, 8+size)
	binary.BigEndian.PutUint64(data, LcmtestPrimitivesT_Fingerprint())

	var d []byte
	if d, err = p.MarshalBinary(); err != nil {
		return
	}

	if copied := copy(data[8:], d); copied != size {
		return []byte{},
			fmt.Errorf("Encoding error, buffer not filled (%v != %v)", copied, size)
	}
	return
}

// MarshalBinary implements the BinaryMarshaller interface
func (p *LcmtestPrimitivesT) MarshalBinary() (data []byte, err error) {
	var size int
	if size, err = p.Size(); err != nil {
		return
	}

	data = make([]byte, size)
	offset := 0

	// LCM struct name: i8
	data[offset] = byte(p.I8)
	offset += 1

	// LCM struct name: i16
	binary.BigEndian.PutUint16(data[offset:],
		uint16(p.I16))
	offset += 2

	// LCM struct name: num_ranges
	binary.BigEndian.PutUint32(data[offset:],
		uint32(p.numRanges))
	offset += 4

	// LCM struct name: i64
	binary.BigEndian.PutUint64(data[offset:],
		uint64(p.I64))
	offset += 8

	// LCM struct name: ranges
	for i0 := int32(0); i0 < p.numRanges; i0++ {
		binary.BigEndian.PutUint16(data[offset:],
			uint16(p.Ranges[i0]))
		offset += 2
	}

	// LCM struct name: position
	for i0 := 0; i0 < 3; i0++ {
		binary.BigEndian.PutUint32(data[offset:],
			math.Float32bits(p.Position[i0]))
		offset += 4
	}

	// LCM struct name: orientation
	for i0 := 0; i0 < 4; i0++ {
		binary.BigEndian.PutUint64(data[offset:],
			math.Float64bits(p.Orientation[i0]))
		offset += 8
	}

	// LCM struct name: name
	{
		bstr := []byte(p.Name)
		binary.BigEndian.PutUint32(data[offset:],
			uint32(len(bstr))+1)
		offset += 4
		offset += copy(data[offset:], bstr)
		data[offset] = 0
		offset += 1
	}

	// LCM struct name: enabled
	if p.Enabled {
		data[offset] = 1
	} else {
		data[offset] = 0
	}
	offset += 1

	return
}

// Decode decodes a message (fingerprint & data) from binary form
// and verifies that the fingerprint match the expected
//
// param data The buffer containing the encoded message
// returns Error
func (p *LcmtestPrimitivesT) Decode(data []byte) (err error) {
	length := len(data)
	if length < 8 {
		return fmt.Errorf("Missing fingerprint in buffer")
	}

	if fp := binary.BigEndian.Uint64(data[:8]); fp != LcmtestPrimitivesT_Fingerprint() {
		return fmt.Errorf("Fingerprints does not match (got %x expected %x)",
			fp, LcmtestPrimitivesT_Fingerprint())
	}

	if err = p.UnmarshalBinary(data[8:]); err != nil {
		return
	}

	length -= 8
	var size int
	if size, err = p.Size(); err != nil {
		return
	}
	if length != size {
		return fmt.Errorf("Missing data in buffer (size missmatch, got %v expected %v)",
			length, size)
	}

	return
}

// UnmarshalBinary implements the BinaryUnmarshaler interface
func (p *LcmtestPrimitivesT) UnmarshalBinary(data []byte) (err error) {
	offset := 0

	p.I8 = int8(data[offset])
	offset += 1

	p.I16 = int16(binary.BigEndian.Uint16(data[offset:]))
	offset += 2

	p.numRanges = int32(binary.BigEndian.Uint32(data[offset:]))
	offset += 4

	p.I64 = int64(binary.BigEndian.Uint64(data[offset:]))
	offset += 8

	p.Ranges = make([]int16, p.numRanges)
	for i0 := int32(0); i0 < p.numRanges; i0++ {
		p.Ranges[i0] = int16(binary.BigEndian.Uint16(data[offset:]))
		offset += 2
	}

	for i0 := 0; i0 < 3; i0++ {
		p.Position[i0] = math.Float32frombits(binary.BigEndian.Uint32(data[offset:]))
		offset += 4
	}

	for i0 := 0; i0 < 4; i0++ {
		p.Orientation[i0] = math.Float64frombits(binary.BigEndian.Uint64(data[offset:]))
		offset += 8
	}

	{
		length := int(binary.BigEndian.Uint32(data[offset:]))
		offset += 4
		if length < 1 {
			return fmt.Errorf("Decoded string length is negative")
		}
		p.Name = string(data[offset : offset+length-1])
		offset += length
	}

	if data[offset] != 0 {
		p.Enabled = true
	} else {
		p.Enabled = false
	}
	offset += 1

	return
}

// NumRanges() returns the value of dynamic array size attribute
// LcmtestPrimitivesT.num_ranges.
// And validates that the size is correct for all fields in which it is used.
func (p *LcmtestPrimitivesT) NumRanges() (int32, error) {
	// Set value to first dynamic array using this size
	// Ranges
	p.numRanges = int32(len(p.Ranges))

	// Return size
	return p.numRanges, nil
}

// Fingerprint generates the LCM fingerprint value for this message
func LcmtestPrimitivesT_Fingerprint(path ...uint64) uint64 {
	for _, v := range path {
		if v == primitives_t_Fingerprint {
			return 0
		}
	}

	path = append(path, primitives_t_Fingerprint)
	return bits.RotateLeft64(primitives_t_Fingerprint, 1)
}

// Size returns the size of this message in bytes
func (p *LcmtestPrimitivesT) Size() (size int, err error) {

	size += 1 // p.I8

	size += 2 // p.I16

	// Validate and populate p.numRanges
	if _, err = p.NumRanges(); err != nil {
		return
	}
	size += 4 // p.numRanges

	size += 8 // p.I64

	for i0 := int32(0); i0 < p.numRanges; i0++ {
		size += 2 // p.Ranges
	}

	for i0 := 0; i0 < 3; i0++ {
		size += 4 // p.Position
	}

	for i0 := 0; i0 < 4; i0++ {
		size += 8 // p.Orientation
	}

	size += 4 // LCM string length
	size += len([]byte(p.Name))
	size += 1 // LCM zero termination

	size += 1 // p.Enabled

	return
}
