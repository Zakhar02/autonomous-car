// THIS IS AN AUTOMATICALLY GENERATED FILE.  DO NOT MODIFY
// BY HAND!!
//
// Generated by lcm-gen

package lcmtest

import (
	"encoding/binary"
	"fmt"
	"math"
	"math/bits"
)

const _ = math.Pi
const _ = bits.UintSize

const multidim_array_t_Fingerprint uint64 = 0x1e012473deb4cfbb

type LcmtestMultidimArrayT struct {
	sizeA    int32       `size_a`
	sizeB    int32       `size_b`
	sizeC    int32       `size_c`
	Data     [][][]int32 `data`
	Strarray [2][]string `strarray`
}

// Copy creates a deep copy
// TODO: fix the fugly x and p names...
func (x *LcmtestMultidimArrayT) Copy() (p LcmtestMultidimArrayT) {
	p.sizeA = x.sizeA

	p.sizeB = x.sizeB

	p.sizeC = x.sizeC

	p.Data = make([][][]int32, p.sizeA)
	for i0 := int32(0); i0 < p.sizeA; i0++ {
		p.Data[i0] = make([][]int32, p.sizeB)
		for i1 := int32(0); i1 < p.sizeB; i1++ {
			p.Data[i0][i1] = make([]int32, p.sizeC)
			for i2 := int32(0); i2 < p.sizeC; i2++ {
				p.Data[i0][i1][i2] = x.Data[i0][i1][i2]
			}
		}
	}

	for i0 := 0; i0 < 2; i0++ {
		p.Strarray[i0] = make([]string, p.sizeC)
		for i1 := int32(0); i1 < p.sizeC; i1++ {
			p.Strarray[i0][i1] = x.Strarray[i0][i1]
		}
	}

	return
}

// Encode encodes a message (fingerprint & data) into binary form
//
// returns Encoded data or error
func (p *LcmtestMultidimArrayT) Encode() (data []byte, err error) {
	var size int
	if size, err = p.Size(); err != nil {
		return
	}

	data = make([]byte, 8+size)
	binary.BigEndian.PutUint64(data, LcmtestMultidimArrayT_Fingerprint())

	var d []byte
	if d, err = p.MarshalBinary(); err != nil {
		return
	}

	if copied := copy(data[8:], d); copied != size {
		return []byte{},
			fmt.Errorf("Encoding error, buffer not filled (%v != %v)", copied, size)
	}
	return
}

// MarshalBinary implements the BinaryMarshaller interface
func (p *LcmtestMultidimArrayT) MarshalBinary() (data []byte, err error) {
	var size int
	if size, err = p.Size(); err != nil {
		return
	}

	data = make([]byte, size)
	offset := 0

	// LCM struct name: size_a
	binary.BigEndian.PutUint32(data[offset:],
		uint32(p.sizeA))
	offset += 4

	// LCM struct name: size_b
	binary.BigEndian.PutUint32(data[offset:],
		uint32(p.sizeB))
	offset += 4

	// LCM struct name: size_c
	binary.BigEndian.PutUint32(data[offset:],
		uint32(p.sizeC))
	offset += 4

	// LCM struct name: data
	for i0 := int32(0); i0 < p.sizeA; i0++ {
		for i1 := int32(0); i1 < p.sizeB; i1++ {
			for i2 := int32(0); i2 < p.sizeC; i2++ {
				binary.BigEndian.PutUint32(data[offset:],
					uint32(p.Data[i0][i1][i2]))
				offset += 4
			}
		}
	}

	// LCM struct name: strarray
	for i0 := 0; i0 < 2; i0++ {
		for i1 := int32(0); i1 < p.sizeC; i1++ {
			{
				bstr := []byte(p.Strarray[i0][i1])
				binary.BigEndian.PutUint32(data[offset:],
					uint32(len(bstr))+1)
				offset += 4
				offset += copy(data[offset:], bstr)
				data[offset] = 0
				offset += 1
			}
		}
	}

	return
}

// Decode decodes a message (fingerprint & data) from binary form
// and verifies that the fingerprint match the expected
//
// param data The buffer containing the encoded message
// returns Error
func (p *LcmtestMultidimArrayT) Decode(data []byte) (err error) {
	length := len(data)
	if length < 8 {
		return fmt.Errorf("Missing fingerprint in buffer")
	}

	if fp := binary.BigEndian.Uint64(data[:8]); fp != LcmtestMultidimArrayT_Fingerprint() {
		return fmt.Errorf("Fingerprints does not match (got %x expected %x)",
			fp, LcmtestMultidimArrayT_Fingerprint())
	}

	if err = p.UnmarshalBinary(data[8:]); err != nil {
		return
	}

	length -= 8
	var size int
	if size, err = p.Size(); err != nil {
		return
	}
	if length != size {
		return fmt.Errorf("Missing data in buffer (size missmatch, got %v expected %v)",
			length, size)
	}

	return
}

// UnmarshalBinary implements the BinaryUnmarshaler interface
func (p *LcmtestMultidimArrayT) UnmarshalBinary(data []byte) (err error) {
	offset := 0

	p.sizeA = int32(binary.BigEndian.Uint32(data[offset:]))
	offset += 4

	p.sizeB = int32(binary.BigEndian.Uint32(data[offset:]))
	offset += 4

	p.sizeC = int32(binary.BigEndian.Uint32(data[offset:]))
	offset += 4

	p.Data = make([][][]int32, p.sizeA)
	for i0 := int32(0); i0 < p.sizeA; i0++ {
		p.Data[i0] = make([][]int32, p.sizeB)
		for i1 := int32(0); i1 < p.sizeB; i1++ {
			p.Data[i0][i1] = make([]int32, p.sizeC)
			for i2 := int32(0); i2 < p.sizeC; i2++ {
				p.Data[i0][i1][i2] = int32(binary.BigEndian.Uint32(data[offset:]))
				offset += 4
			}
		}
	}

	for i0 := 0; i0 < 2; i0++ {
		p.Strarray[i0] = make([]string, p.sizeC)
		for i1 := int32(0); i1 < p.sizeC; i1++ {
			{
				length := int(binary.BigEndian.Uint32(data[offset:]))
				offset += 4
				if length < 1 {
					return fmt.Errorf("Decoded string length is negative")
				}
				p.Strarray[i0][i1] = string(data[offset : offset+length-1])
				offset += length
			}
		}
	}

	return
}

// SizeA() returns the value of dynamic array size attribute
// LcmtestMultidimArrayT.size_a.
// And validates that the size is correct for all fields in which it is used.
func (p *LcmtestMultidimArrayT) SizeA() (int32, error) {
	// Set value to first dynamic array using this size
	// Data
	p.sizeA = int32(len(p.Data))

	// Return size
	return p.sizeA, nil
}

// SizeB() returns the value of dynamic array size attribute
// LcmtestMultidimArrayT.size_b.
// And validates that the size is correct for all fields in which it is used.
func (p *LcmtestMultidimArrayT) SizeB() (int32, error) {
	for i0 := int32(0); i0 < p.sizeA; i0++ {
		// Set value to first dynamic array using this size
		// Data[i0]
			p.sizeB = int32(len(p.Data[i0]))
		// Validate size matches all other dynamic arrays

		// Data[i0]
		if int(p.sizeB) != len(p.Data[i0]) {
			return 0, fmt.Errorf("Defined dynamic array size not "+
				"matching actual array size (got %d expected %d for Data[i0])",
				len(p.Data[i0]), p.sizeB)
		}
	}

	// Return size
	return p.sizeB, nil
}

// SizeC() returns the value of dynamic array size attribute
// LcmtestMultidimArrayT.size_c.
// And validates that the size is correct for all fields in which it is used.
func (p *LcmtestMultidimArrayT) SizeC() (int32, error) {
	for i0 := int32(0); i0 < p.sizeA; i0++ {
		for i1 := int32(0); i1 < p.sizeB; i1++ {
			// Set value to first dynamic array using this size
			// Data[i0][i1]
				p.sizeC = int32(len(p.Data[i0][i1]))
			// Validate size matches all other dynamic arrays

			// Data[i0][i1]
			if int(p.sizeC) != len(p.Data[i0][i1]) {
				return 0, fmt.Errorf("Defined dynamic array size not "+
					"matching actual array size (got %d expected %d for Data[i0][i1])",
					len(p.Data[i0][i1]), p.sizeC)
			}
		}
	}

	for i0 := 0; i0 < 2; i0++ {
		// Validate size matches all other dynamic arrays

		// Strarray[i0]
		if int(p.sizeC) != len(p.Strarray[i0]) {
			return 0, fmt.Errorf("Defined dynamic array size not "+
				"matching actual array size (got %d expected %d for Strarray[i0])",
				len(p.Strarray[i0]), p.sizeC)
		}
	}

	// Return size
	return p.sizeC, nil
}

// Fingerprint generates the LCM fingerprint value for this message
func LcmtestMultidimArrayT_Fingerprint(path ...uint64) uint64 {
	for _, v := range path {
		if v == multidim_array_t_Fingerprint {
			return 0
		}
	}

	path = append(path, multidim_array_t_Fingerprint)
	return bits.RotateLeft64(multidim_array_t_Fingerprint, 1)
}

// Size returns the size of this message in bytes
func (p *LcmtestMultidimArrayT) Size() (size int, err error) {

	// Validate and populate p.sizeA
	if _, err = p.SizeA(); err != nil {
		return
	}
	size += 4 // p.sizeA

	// Validate and populate p.sizeB
	if _, err = p.SizeB(); err != nil {
		return
	}
	size += 4 // p.sizeB

	// Validate and populate p.sizeC
	if _, err = p.SizeC(); err != nil {
		return
	}
	size += 4 // p.sizeC

	for i0 := int32(0); i0 < p.sizeA; i0++ {
		for i1 := int32(0); i1 < p.sizeB; i1++ {
			for i2 := int32(0); i2 < p.sizeC; i2++ {
				size += 4 // p.Data
			}
		}
	}

	for i0 := 0; i0 < 2; i0++ {
		for i1 := int32(0); i1 < p.sizeC; i1++ {
			size += 4 // LCM string length
			size += len([]byte(p.Strarray[i0][i1]))
			size += 1 // LCM zero termination
		}
	}

	return
}
