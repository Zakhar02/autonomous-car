// THIS IS AN AUTOMATICALLY GENERATED FILE.  DO NOT MODIFY
// BY HAND!!
//
// Generated by lcm-gen

package lcmtest

import (
	"encoding/binary"
	"fmt"
	"math"
	"math/bits"
)

const _ = math.Pi
const _ = bits.UintSize

const bools_t_Fingerprint uint64 = 0x91cff66a81b52b83

type LcmtestBoolsT struct {
	OneBool     bool     `one_bool`
	FixedArray  [3]bool  `fixed_array`
	numA        int8     `num_a`
	numB        int8     `num_b`
	OneDimArray []bool   `one_dim_array`
	TwoDimArray [][]bool `two_dim_array`
}

// Copy creates a deep copy
// TODO: fix the fugly x and p names...
func (x *LcmtestBoolsT) Copy() (p LcmtestBoolsT) {
	p.OneBool = x.OneBool

	for i0 := 0; i0 < 3; i0++ {
		p.FixedArray[i0] = x.FixedArray[i0]
	}

	p.numA = x.numA

	p.numB = x.numB

	p.OneDimArray = make([]bool, p.numA)
	for i0 := int8(0); i0 < p.numA; i0++ {
		p.OneDimArray[i0] = x.OneDimArray[i0]
	}

	p.TwoDimArray = make([][]bool, p.numA)
	for i0 := int8(0); i0 < p.numA; i0++ {
		p.TwoDimArray[i0] = make([]bool, p.numB)
		for i1 := int8(0); i1 < p.numB; i1++ {
			p.TwoDimArray[i0][i1] = x.TwoDimArray[i0][i1]
		}
	}

	return
}

// Encode encodes a message (fingerprint & data) into binary form
//
// returns Encoded data or error
func (p *LcmtestBoolsT) Encode() (data []byte, err error) {
	var size int
	if size, err = p.Size(); err != nil {
		return
	}

	data = make([]byte, 8+size)
	binary.BigEndian.PutUint64(data, LcmtestBoolsT_Fingerprint())

	var d []byte
	if d, err = p.MarshalBinary(); err != nil {
		return
	}

	if copied := copy(data[8:], d); copied != size {
		return []byte{},
			fmt.Errorf("Encoding error, buffer not filled (%v != %v)", copied, size)
	}
	return
}

// MarshalBinary implements the BinaryMarshaller interface
func (p *LcmtestBoolsT) MarshalBinary() (data []byte, err error) {
	var size int
	if size, err = p.Size(); err != nil {
		return
	}

	data = make([]byte, size)
	offset := 0

	// LCM struct name: one_bool
	if p.OneBool {
		data[offset] = 1
	} else {
		data[offset] = 0
	}
	offset += 1

	// LCM struct name: fixed_array
	for i0 := 0; i0 < 3; i0++ {
		if p.FixedArray[i0] {
			data[offset] = 1
		} else {
			data[offset] = 0
		}
		offset += 1
	}

	// LCM struct name: num_a
	data[offset] = byte(p.numA)
	offset += 1

	// LCM struct name: num_b
	data[offset] = byte(p.numB)
	offset += 1

	// LCM struct name: one_dim_array
	for i0 := int8(0); i0 < p.numA; i0++ {
		if p.OneDimArray[i0] {
			data[offset] = 1
		} else {
			data[offset] = 0
		}
		offset += 1
	}

	// LCM struct name: two_dim_array
	for i0 := int8(0); i0 < p.numA; i0++ {
		for i1 := int8(0); i1 < p.numB; i1++ {
			if p.TwoDimArray[i0][i1] {
				data[offset] = 1
			} else {
				data[offset] = 0
			}
			offset += 1
		}
	}

	return
}

// Decode decodes a message (fingerprint & data) from binary form
// and verifies that the fingerprint match the expected
//
// param data The buffer containing the encoded message
// returns Error
func (p *LcmtestBoolsT) Decode(data []byte) (err error) {
	length := len(data)
	if length < 8 {
		return fmt.Errorf("Missing fingerprint in buffer")
	}

	if fp := binary.BigEndian.Uint64(data[:8]); fp != LcmtestBoolsT_Fingerprint() {
		return fmt.Errorf("Fingerprints does not match (got %x expected %x)",
			fp, LcmtestBoolsT_Fingerprint())
	}

	if err = p.UnmarshalBinary(data[8:]); err != nil {
		return
	}

	length -= 8
	var size int
	if size, err = p.Size(); err != nil {
		return
	}
	if length != size {
		return fmt.Errorf("Missing data in buffer (size missmatch, got %v expected %v)",
			length, size)
	}

	return
}

// UnmarshalBinary implements the BinaryUnmarshaler interface
func (p *LcmtestBoolsT) UnmarshalBinary(data []byte) (err error) {
	offset := 0

	if data[offset] != 0 {
		p.OneBool = true
	} else {
		p.OneBool = false
	}
	offset += 1

	for i0 := 0; i0 < 3; i0++ {
		if data[offset] != 0 {
			p.FixedArray[i0] = true
		} else {
			p.FixedArray[i0] = false
		}
		offset += 1
	}

	p.numA = int8(data[offset])
	offset += 1

	p.numB = int8(data[offset])
	offset += 1

	p.OneDimArray = make([]bool, p.numA)
	for i0 := int8(0); i0 < p.numA; i0++ {
		if data[offset] != 0 {
			p.OneDimArray[i0] = true
		} else {
			p.OneDimArray[i0] = false
		}
		offset += 1
	}

	p.TwoDimArray = make([][]bool, p.numA)
	for i0 := int8(0); i0 < p.numA; i0++ {
		p.TwoDimArray[i0] = make([]bool, p.numB)
		for i1 := int8(0); i1 < p.numB; i1++ {
			if data[offset] != 0 {
				p.TwoDimArray[i0][i1] = true
			} else {
				p.TwoDimArray[i0][i1] = false
			}
			offset += 1
		}
	}

	return
}

// NumA() returns the value of dynamic array size attribute
// LcmtestBoolsT.num_a.
// And validates that the size is correct for all fields in which it is used.
func (p *LcmtestBoolsT) NumA() (int8, error) {
	// Set value to first dynamic array using this size
	// OneDimArray
	p.numA = int8(len(p.OneDimArray))

	// Validate size matches all other dynamic arrays

	// TwoDimArray
	if int(p.numA) != len(p.TwoDimArray) {
		return 0, fmt.Errorf("Defined dynamic array size not "+
			"matching actual array size (got %d expected %d for TwoDimArray)",
			len(p.TwoDimArray), p.numA)
	}

	// Return size
	return p.numA, nil
}

// NumB() returns the value of dynamic array size attribute
// LcmtestBoolsT.num_b.
// And validates that the size is correct for all fields in which it is used.
func (p *LcmtestBoolsT) NumB() (int8, error) {
	for i0 := int8(0); i0 < p.numA; i0++ {
		// Set value to first dynamic array using this size
		// TwoDimArray[i0]
			p.numB = int8(len(p.TwoDimArray[i0]))
		// Validate size matches all other dynamic arrays

		// TwoDimArray[i0]
		if int(p.numB) != len(p.TwoDimArray[i0]) {
			return 0, fmt.Errorf("Defined dynamic array size not "+
				"matching actual array size (got %d expected %d for TwoDimArray[i0])",
				len(p.TwoDimArray[i0]), p.numB)
		}
	}

	// Return size
	return p.numB, nil
}

// Fingerprint generates the LCM fingerprint value for this message
func LcmtestBoolsT_Fingerprint(path ...uint64) uint64 {
	for _, v := range path {
		if v == bools_t_Fingerprint {
			return 0
		}
	}

	path = append(path, bools_t_Fingerprint)
	return bits.RotateLeft64(bools_t_Fingerprint, 1)
}

// Size returns the size of this message in bytes
func (p *LcmtestBoolsT) Size() (size int, err error) {

	size += 1 // p.OneBool

	for i0 := 0; i0 < 3; i0++ {
		size += 1 // p.FixedArray
	}

	// Validate and populate p.numA
	if _, err = p.NumA(); err != nil {
		return
	}
	size += 1 // p.numA

	// Validate and populate p.numB
	if _, err = p.NumB(); err != nil {
		return
	}
	size += 1 // p.numB

	for i0 := int8(0); i0 < p.numA; i0++ {
		size += 1 // p.OneDimArray
	}

	for i0 := int8(0); i0 < p.numA; i0++ {
		for i1 := int8(0); i1 < p.numB; i1++ {
			size += 1 // p.TwoDimArray
		}
	}

	return
}
